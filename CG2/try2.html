<!DOCTYPE html>
<html>
<head>
    <title>3D Bullet Shooter</title>
</head>
<body>
    <canvas id="canvas" width="400" height="400"></canvas>
    <script src="https://webgl2fundamentals.org/webgl/resources/twgl-full.min.js"></script>
    <script src="https://webgl2fundamentals.org/webgl/resources/webgl-utils.js"></script>
    <script src="https://webgl2fundamentals.org/webgl/resources/m4.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.8.1/gl-matrix-min.js"></script>
    <script src="https://webgl2fundamentals.org/webgl/resources/webgl-lessons-ui.js"></script>

    <script type="text/javascript">
        async function main() {
            const canvas = document.getElementById("canvas");
            const gl = canvas.getContext("webgl2");

            if (!gl) {
                alert("WebGL 2 is not supported by your browser.");
            }

            const bullets = [];
            const maxBullets = 5;

            //pega as posições x, y, z do mouse em relação ao canvas 
            //quando clicado e bota numa array
            canvas.addEventListener("mousedown", (e) => { 
                if (bullets.length < maxBullets) {
                    const bullet = {
                        x: 0,
                        y: 0,
                        z: 0,
                        speed: 0.02,
                    };

                    const viewport = canvas.getBoundingClientRect();
                    const mouseX = e.clientX - viewport.left;
                    const mouseY = canvas.height - (e.clientY - viewport.top);

                    bullet.x = (mouseX / canvas.width) * 2 - 1;
                    bullet.y = (mouseY / canvas.height) * 2 - 1;

                    bullets.push(bullet);
                }
            });

            //pra criar os vértices da esfera. pega raio e nr de segmento pra poder fazer, + segmento = smoother
            function createSphere(radius) {
                var segments = 10;//10 segmentos pra poder fazer a esfera fica smooth enough
                const sphereVertices = [];

                for (let phi = 0; phi <= Math.PI; phi += Math.PI / segments) {
                    for (let theta = 0; theta < 2 * Math.PI; theta += Math.PI / segments) {
                        const x = radius * Math.sin(phi) * Math.cos(theta); //sin cos
                        const y = radius * Math.sin(phi) * Math.sin(theta); //cos sin
                        const z = radius * Math.cos(phi); //only cos

                        sphereVertices.push(x, y, z);
                    }
                }

                return new Float32Array(sphereVertices);
            }

            const sphereVertices = createSphere(0.1);

            //shader stuff quebrado
            function createShaderProgram(gl) {
                const vsSource = `
                    attribute vec4 a_position;
                    uniform mat4 u_modelViewMatrix;
                    void main(void) {
                        gl_Position = u_modelViewMatrix * a_position;
                    }
                `;

                const fsSource = `
                    precision mediump float;
                    void main(void) {
                        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);
                    }
                `;

                const vertexShader = compileShader(gl, vsSource, gl.VERTEX_SHADER);
                const fragmentShader = compileShader(gl, fsSource, gl.FRAGMENT_SHADER);

                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);

                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    alert('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                    return null;
                }

                return shaderProgram;
            }

                        function drawScene() {
                gl.clearColor(0.0, 0.0, 0.0, 1.0); //clear canvas
                gl.clear(gl.COLOR_BUFFER_BIT);

                for (let i = 0; i < bullets.length; i++) {
                    const bullet = bullets[i];
                    
                    //faz buffer pros vertices da esfera
                    const bulletVertexBuffer = gl.createBuffer();
                    gl.bindBuffer(gl.ARRAY_BUFFER, bulletVertexBuffer);
                    gl.bufferData(gl.ARRAY_BUFFER, sphereVertices, gl.STATIC_DRAW);
                    
                    //vai pro vertex shader renderizar
                    const shaderProgram = createShaderProgram(gl);
                    gl.useProgram(shaderProgram);

                    //faz os atributos q no nosso caso são as pos
                    const positionAttributeLocation = gl.getAttribLocation(shaderProgram, 'a_position');
                    gl.enableVertexAttribArray(positionAttributeLocation);
                    gl.bindBuffer(gl.ARRAY_BUFFER, bulletVertexBuffer);
                    gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);


                    //bota a esfera no lugar da bullet com mats:
                    const modelMatrix = mat4.create();
                    const projectionMatrix = mat4.create();
                    const modelViewMatrix = mat4.create();

                    mat4.translate(modelMatrix, modelMatrix, [bullet.x, bullet.y, bullet.z]);
                    mat4.ortho(projectionMatrix, -1, 1, -1, 1, -10, 10);
                    mat4.multiply(modelViewMatrix, projectionMatrix, modelMatrix);

                    const modelViewMatrixLocation = gl.getUniformLocation(shaderProgram, 'u_modelViewMatrix');
                    gl.uniformMatrix4fv(modelViewMatrixLocation, false, modelViewMatrix);

                    //desenha esfera
                    gl.drawArrays(gl.TRIANGLE_FAN, 0, sphereVertices.length / 3);
                }
            }

            function compileShader(gl, source, type) {
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);

                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    alert('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            function update() {
                drawScene();
                requestAnimationFrame(update);
            }

            update();
        }

        main();
    </script>
</body>
</
